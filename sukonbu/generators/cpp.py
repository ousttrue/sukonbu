import pathlib
from typing import List, Tuple, Optional
from jinja2 import Template
from ..json_schema import JsonSchema
from ..json_schema_parser import JsonSchemaParser

CPP_BEGIN = '''// this is generated by sukonbu
#include <optional>
#include <vector>
#include <string>
#include <unordered_map>

namespace sukonbu {
'''

CPP_END = '''} // namespace sukonbu
'''

CPP_ENUM = Template('''
enum class {{ class_name }}
{
{%- for prop in props %}
    {{ prop }},
{%- endfor %}
};

''')

CPP_CLASS = Template('''
struct {{ class_name }}
{
{%- for prop in props %}
    // {{ prop[0] }}
    {{ prop[1] }};
{%- endfor %}
};

''')


def js_to_cpp_type(name: str, js: JsonSchema, parent: JsonSchema) -> str:
    '''
    convert JsonSchema to cpp type
    '''
    if js.title in ['Extension', 'Extras']:
        return js.get_class_name()

    enum_values = js.get_enum_values()
    if enum_values:
        return js.title

    if js.type == 'integer':
        return 'int'
    if js.type == 'number':
        return 'float'
    elif js.type == 'boolean':
        return 'bool'
    elif js.type == 'string':
        return 'std::u8string'
    elif js.type == 'object':
        if js.properties and js.additionalProperties:
            raise Exception()
        if js.properties:
            return js.get_class_name()
        elif js.additionalProperties:
            return f'std::unordered_map<std::u8string, {js_to_cpp_type(name, js.additionalProperties, js)}>'
        else:
            return 'Object[string]'
    elif js.type == 'array':
        return f'std::vector<{js_to_cpp_type(name, js.items, js)}>'
    elif js.type == 'unknown':
        return 'Object[string]'
    else:
        raise Exception()
        # return js.type, 'None'


def escape_enum(src: str) -> str:
    splitted = src.split('/')
    if len(splitted) > 1:
        # ex. image/jpg
        return ''.join(x for x in splitted)
    else:
        return src


def enum_value(src: str) -> str:
    splitted = src.split('=')
    if len(splitted) == 2:
        # int
        return f'{escape_enum(splitted[0])} = {splitted[1]}'
    else:
        # str
        return f'{escape_enum(splitted[0])} /* = "{splitted[0]}" */'


def add_optional(js: JsonSchema, src: str, required: bool) -> str:
    if js.type in ['string', 'array', 'enum']:
        return f'{src}'
    return f'std::optional<{src}>'


def escape_symbol(name: str) -> str:
    if name in ['version']:
        return name + '_'
    else:
        return name


def read_func(name: str, js: JsonSchema, parent: Optional[JsonSchema]) -> str:
    '''
    fromJSON
    '''

    if js.get_enum_values():
        if not parent:
            raise Exception()
        if js.type == 'string':
            return f'if(const(JSONValue)* x = "{name}" in src){{ value.{escape_symbol(name)} = to!{js.title}(x.str); }}'
        else:
            return f'if(const(JSONValue)* x = "{name}" in src){{ value.{escape_symbol(name)} = cast({js.title})x.integer; }}'

    if js.properties:
        # object
        return f'if(const(JSONValue)* x = "{name}" in src){{ value.{escape_symbol(name)} = {js.get_class_name()}.fromJSON(src["{name}"]); }}'

    if js.additionalProperties:
        # assocArray
        if js.additionalProperties.type == 'integer':
            return f'if(const(JSONValue)* x = "{name}" in src){{ value.{escape_symbol(name)} = x.object.byPair.map!(kv => tuple(kv.key, cast(int)kv.value.integer)).assocArray; }}'

    if js.type == 'array':
        items = js.items
        if items.properties:
            return f'if(const(JSONValue)* x = "{name}" in src){{ value.{escape_symbol(name)} = x.array.map!(a => {items.get_class_name()}.fromJSON(a)).array; }}'
        else:
            if items.type == 'integer':
                # must range to array
                # https://stackoverflow.com/questions/13125446/converting-string-to-char?rq=1
                return f'if(const(JSONValue)* x = "{name}" in src){{ value.{escape_symbol(name)} = x.array.map!(a => cast(int)a.integer).array; }}'
            elif items.type == 'number':
                return f'if(const(JSONValue)* x = "{name}" in src){{ value.{escape_symbol(name)} = x.array.map!(a => a.asFloat).array; }}'
            elif items.type == 'string':
                return f'if(const(JSONValue)* x = "{name}" in src){{ value.{escape_symbol(name)} = x.array.map!(a => a.str).array; }}'
            elif items.additionalProperties:
                if items.additionalProperties.type == 'integer':
                    return f'if(const(JSONValue)* x = "{name}" in src){{ value.{escape_symbol(name)} = x.array.map!(a => a.object.byPair.map!(kv => tuple(kv.key, cast(int)kv.value.integer)).assocArray).array; }}'

                else:
                    raise NotImplementedError()

    if js.type == 'integer':
        return f'if(const(JSONValue)* x = "{name}" in src){{ value.{escape_symbol(name)} = nullable(cast(int)x.integer); }}'
    elif js.type == 'number':
        return f'if(const(JSONValue)* x = "{name}" in src){{ value.{escape_symbol(name)} = nullable(x.asFloat); }}'
    elif js.type == 'string':
        return f'if(const(JSONValue)* x = "{name}" in src){{ value.{escape_symbol(name)} = x.str; }}'
    elif js.type == 'boolean':
        return f'if(const(JSONValue)* x = "{name}" in src){{ value.{escape_symbol(name)} = x.boolean; }}'

    return f'// not implemented: {js.type}'


def write_func(name: str, js: JsonSchema, parent: Optional[JsonSchema]) -> str:
    '''
    to_dict
    '''
    return ''


def generate(parser: JsonSchemaParser, dst: pathlib.Path) -> None:

    print(f'write: {dst}')
    dst.parent.mkdir(parents=True, exist_ok=True)
    with dst.open('w') as w:
        w.write(CPP_BEGIN)

        for key, js, parent in parser.schemas:
            enum_values = js.get_enum_values()
            if enum_values:
                if not parent:
                    raise Exception()
                value_map = {
                    'class_name': js.title,
                    'props': [enum_value(value) for value in enum_values],
                }
                w.write(CPP_ENUM.render(**value_map))

            elif js.title in ['Extension', 'Extras']:
                if not parent:
                    raise Exception()
                value_map = {
                    'class_name': js.get_class_name(),
                    'props': [],
                    'writes': [],
                    'reads': [],
                }
                w.write(CPP_CLASS.render(**value_map))

            elif js.properties:
                props = [(
                    v.description,
                    f'{add_optional(v, js_to_cpp_type(k, v, js), k in js.required)} {escape_symbol(k)}'
                ) for k, v in js.properties.items()]
                value_map = {
                    'class_name':
                    js.get_class_name(),
                    'props':
                    sorted(props, key=lambda x: '=' in x[1]),
                    'writes':
                    [write_func(k, v, js) for k, v in js.properties.items()],
                    'reads':
                    [read_func(k, v, js) for k, v in js.properties.items()]
                }
                w.write(CPP_CLASS.render(**value_map))

        w.write(CPP_END)
